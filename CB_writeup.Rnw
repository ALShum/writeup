\documentclass{article}
\usepackage{url}
\usepackage{amsfonts}
\usepackage[backend=bibtex, natbib=true]{biblatex}
\addbibresource{references.bib}

\usepackage[margin=1in]{geometry}
\setlength{\parindent}{0in}

\title{Accessing Data with the Census Bureau API}
\author{Alex Shum}
\begin{document}
\maketitle

\section{Introduction}
The United States Census Bureau has been conducting a decennial census since 1790.  Originally this census was a simply to count the population across the country.  More recently the decennial census includes a short-form asking for name, sex, age, and a few other demographic variables.  About one in six households also received a long-form that contained additional socioeconomic questions.  After the 2000 decennial census many of the long-form questions were collected as part of a new survey: the American Community Survey (ACS).  \\
\\
The ACS is an ongoing yearly survey that collects additional demographic variables including but not limited to age, sex, race, income and education.  Unlike the decennial census, the American Community Survey is distributed based on a random selection of addresses every year.  Although the ACS is only sent to a sample of all US households, this data is meant to provide more up to date information than the Census Bureau's decennial census.  Both the decennial census and the American Community Survey are required to be completed by law; however it should be noted that the Census Bureau has not opted to prosecute anyone for failure to complete the decennial census or the ACS.  Despite the lack of enforcement, the ACS still reports a response rate of 97$\%$.\\ %http://www.politifact.com/texas/statements/2014/jan/09/us-census-bureau/americans-must-answer-us-census-bureau-survey-law-/
\\
Both the decennial survey and the ACS data are used in part by federal, state and local agencies to allocate state funding and for policy decisions.  The Census Bureau has also released some of this data for public use.  Many of the data sets are available directly in a compressed format from the Census Bureau's FTP site: \url{http://ftp2.census.gov/}.  Since 2012, the Census Bureau has also included an online developer's API in order to improve accessibility of the ACS and decennial census datasets.  The Census Bureau's online API can be accessed online: \url{http://api.census.gov}.\\
\\
We will discuss how the ACS data is structured when we request data and how to access data from the Census Bureau's online developer's API.  We will also discuss what kind of variables are available and some limitations with the API.  We will base this discussion on a paper by \citet{stangl:2013} as a starting point on some of the limitations of the API.  This article explores some multivariate frequency distributions using data from the ACS dataset; however, there are some gaps in what we can access and inconsistencies in the database.

\section{Requesting Data}
To access data from the census bureau online API we need to construct a proper HTTP GET request.  A valid GET request is formed through a constructed web URL and we specify which dataset, year, variable and geographies that we are requesting.  The basic structure of an HTTP GET request for the decennial census and for the ACS is as follows:
\begin{verbatim}
http://api.census.gov/data/[YEAR]/[DATASET]?key=[KEY]&get=[VARIABLES]&for=[GEOGRAPHY]
\end{verbatim}
$[$KEY$]$ is an id code required to perform a valid GET request.  A developer's key uniquely identifies everyone who requests data from the API.  Requesting a key can be done by registering at \url{http://www.census.gov/developers/tos/key_request.html}.\\
\\
$[$YEAR$]$ and $[$DATASET$]$ specify the dataset and year of the data requested.  The available datasets include the decennial census and the ACS.  The ACS datasets are available in 1-year, 3-year and 5-year timeframes.  The $[$YEAR$]$ variable for the ACS datasets indicates the final year in the timeframe.  For example, the 2012 5-year ACS dataset this is the ACS dataset that spans 2008-2012 and the 2012 3-year ACS dataset is the ACS dataset that spans 2010-2012.  For the decennial census the $[$YEAR$]$ indicates the year the census data was collected.  When we request a $[$DATASET$]$ we use abbreviations for the dataset we want: the ACS 5-year dataset is $acs5$.  See table \ref{tab:datasettable} to see which timeframes are available for each dataset and the associated id assigned by the census bureau.\\
<<datasettable, echo=FALSE, warning=FALSE, message=FALSE, results='asis'>>=
library(xtable)
sets = data.frame(DATASETS = c("Decennial Census", "ACS 5-year", "ACS 3-year", "ACS 1-year"),
                  YEAR = c("1990, 2000, 2010", "2010, 2011, 2012", "2011, 2012", "2011, 2012"),
                  ID = c("sf1", "acs5", "acs3", "acs1"))

tabl = xtable(sets, label="tab:datasettable", caption="Datasets and Years")
print(tabl, include.rownames=FALSE)
@
If we wanted to request some data from the 2010 decennial census we would format our HTTP GET request as follows:
\begin{verbatim}
http://api.census.gov/data/2010/sf1?key=[KEY]&get=[VARIABLES]&for=[GEOGRAPHY]
\end{verbatim}
Similarly requesting data from the 2011 ACS 3-year dataset would require the following HTTP GET request:
\begin{verbatim}
http://api.census.gov/data/2011/acs3?key=[KEY]&get=[VARIABLES]&for=[GEOGRAPHY]
\end{verbatim}
$[$GEOGRAPHY$]$ describes the geographic region of interest.  We can choose varying levels of geographic areas including the entire United States:
\begin{verbatim}
http://api.census.gov/data/[YEAR]/[DATASET]?key=[KEY]&get=[VARIABLES]&for=us:*
\end{verbatim}
We can also specify states using varying levels of detail:
\begin{verbatim}
http://api.census.gov/data/[YEAR]/[DATASET]?key=[KEY]&get=[VARIABLES]&for=state:*
http://api.census.gov/data/[YEAR]/[DATASET]?key=[KEY]&get=[VARIABLES]&for=state:06
http://api.census.gov/data/[YEAR]/[DATASET]?key=[KEY]&get=[VARIABLES]&for=state:01,06
\end{verbatim}
The above HTTP GET requests specify all states, a specific state (California), or multiple states (Alabama and California) respectively.  Some geographic regions are nested within larger regions and we can specify the containing region.  For example, states contain counties and we can form an HTTP GET request for a certain county within a specific state:
\begin{verbatim}
http://api.census.gov/data/[YEAR]/[DATASET]?key=[KEY]&get=[VARIABLES]&for=county:*&in=state:06
http://api.census.gov/data/[YEAR]/[DATASET]?key=[KEY]&get=[VARIABLES]&for=county:037&in=state:06
\end{verbatim}
In the above HTTP GET requests we specify all counties in California and Los Angeles County in California respectively.  Finally, there are even smaller geographic regions that we can specify multiple containing regions.  For example, census tracts are within counties and states.  We can specify a certain census tract within a county:
\begin{verbatim}
http://api.census.gov/data/[YEAR]/[DATASET]?key=[KEY]&get=[VARIABLES]&for=tract:*&in=state:06+county037:
http://api.census.gov/data/[YEAR]/[DATASET]?key=[KEY]&get=[VARIABLES]&for=tract:101110&in=state:06+county037:
\end{verbatim}
In the above HTTP GET requests we specify all census tracts within Los Angeles County and census tract 1011.10 within Los Angeles County respectively.\\
\\
Specifying a correct geographic region or combination of regions and specifying available demographic variables ($[$VARIABLES$]$) require a more detailed knowledge of how the census datasets are organized.  We discuss geographies in section \ref{sec:geo} and variables in section \ref{sec:var}.  We also discuss how the data is formatted and structured in section \ref{sec:var}.

\section{Geography}
\label{sec:geo}
The Census Bureau has a very sophisticated system of hierarchy for geographic entities.  For the ACS, at the top level there is the entire nation, followed by region, division, state, county, county-subdivision, tract, block group, place, congressional district, zip code area, school district and a few other geographic divisions.  See table \ref{tab:geolist} for a complete table of geographic entities available on the census API for the 2012 ACS.\\

<<geotable, echo=FALSE, warning=FALSE, message=FALSE, eval=FALSE>>=
#http://api.census.gov/data/2012/acs5/geo.html
library(xtable)
library(XML)
ta = readHTMLTable("http://api.census.gov/data/2012/acs5/geo.html")[[1]]
ta = ta[,-3]
tabl = xtable(ta, label="tab:geolist")
caption(tabl) = "List of valid geographic combinations"
# print(tabl, include.rownames=FALSE)
@
\begin{table}[ht]
\centering
\begin{tabular}{ll}
  \hline
Summary Level & Description \\ 
  \hline
  010 & us \\ 
  020 & region \\ 
  030 & division \\ 
  040 & state \\ 
  050 & state-county \\ 
  060 & state-county-county subdivision \\ 
  140 & state-county-tract \\ 
  150 & state-county-tract-block group \\ 
  160 & state-place \\ 
  250 & american indian area/alaska native area/hawaiian home land \\ 
  310 & metropolitan statistical area/micropolitan statistical area \\ 
  320 & state-metropolitan statistical area/micropolitan statistical area \\ 
  330 & combined statistical area \\ 
  340 & state-combined statistical area \\ 
  350 & new england city and town area \\ 
  400 & urban area \\ 
  500 & state-congressional district \\ 
  510 & state-congressional district-county \\ 
  610 & state-state legislative district (upper chamber) \\ 
  620 & state-state legislative district (lower chamber) \\ 
  795 & state-public use microdata area \\ 
  950 & state-school district (elementary) \\ 
  960 & state-school district (secondary) \\ 
  970 & state-school district (unified) \\ 
   \hline
\end{tabular}
\caption{List of valid geographic combinations for 2012 ACS 5-year}
\label{tab:geolist}
\end{table}

From table \ref{tab:geolist}, there is a specific hierarchy of geographic regions and specific valid combinations of geographic regions.  Different ACS datasets might have slightly different geographic regions available.  For example, in the 2010 decennial census if our geographic area is zip code tabulation areas then we are required to specify states.  By contrast, the 2012 ACS 5-year dataset has zip code tabulation areas but we do not need to specify states.  The 2010 ACS 5-year dataset simply does not have zip code tabulation areas available.  Fortunately, each dataset available on the Census Bureau online API include an associated geography file formatted in JSON and a similar file formatted in XML.  JSON stands for JavaScript Object Notation and it is a lightweight machine format for sending data.  JSON is structured using name-value pairs and is also designed to be human-readable.  There are many libraries to generate and process JSON.  The JSON formatted file for geographies has the following format:
\begin{verbatim}
{
  "name": "tract",
  "requires": [
    "state",
    "county"
  ],
  "optionalWithWCFor": "county"
}
\end{verbatim}
This JSON file specifies that for census tract level geography we are always required to specify a state.  We are required to specify a county in certain cases.  If we want all census tracts within a state then we are required to specify state.  If we want all census tracts within a county then we need to specify a state and a county.  If we want a specific census tract, we must specify both a county and a state.  This is due to how census tracts are labelled; it's possible that census tracts located in different states and counties have the same label.\\
\\
The same geographic information is also available in XML.  XML stands for Extensible Markup Language and is similar in structure to the HTML format used for webpages.  XML is another format for sending and storing data.  It is formatted in a tree-like structure with a hierarchy of categories with associated values.  Here is the same geographic area information formatted in XML:
\begin{verbatim}
<fips name="tract">
  <requires name="state"/>
  <requires name="county" is-optional-with-wcfor="true"/>
</fips>
\end{verbatim}
In the following examples, we will examine various geographies available from the online API and see which combinations of geographic regions are required.  We will use the United States as a whole and various geographic areas within the state of California for our examples.\\
<<state, echo=FALSE, warning=FALSE, message=FALSE, fig.height=3, fig.width=5, cache=TRUE, fig.cap='California Selected', fig.align='center'>>=
library(ggplot2)
states.map = map_data("state")
states.map$CA = states.map$region=="california"
qplot(long, lat, data=states.map, group=group, order=order, geom="polygon", fill=CA, size=1) + 
  theme_bw() + coord_map() + theme(axis.ticks = element_blank(), axis.text.x = element_blank(), axis.title.x=element_blank(), axis.text.y = element_blank(), axis.title.y=element_blank(), panel.grid = element_blank(), panel.border = element_blank(), legend.position = "none")
@
At the top of the geography hierarchy we can form valid HTTP GET requests specifying a country-wide geography; this is data aggregated among all states and corresponds to summary level 010 from table \ref{tab:geolist}.  Below that we specify a state-level geography.  At this level we can view data for all states or select a particular state; this is summary level 040.  In figure \ref{fig:state} we have selected California with the following HTTP GET request: \url{http://api.census.gov/data/[YEAR]/[DATASET]?key=[KEY]&get=[VARIABLES]&for=state:06}.\\

<<county, echo=FALSE, warning=FALSE, message=FALSE, fig.height=3, fig.width=5, cache=TRUE, fig.cap='Los Angeles county selected',  fig.align='center'>>=
counties.map = map_data("county")
counties.map$CA = as.numeric(counties.map$region=="california")
counties.map[counties.map$region=="california" & counties.map$subregion=="los angeles",]$CA = 2
qplot(long, lat, data=counties.map, group=group, order=order, geom="polygon", fill=factor(CA)) + 
  theme_bw() + coord_map() + theme(axis.ticks = element_blank(), axis.text.x = element_blank(), axis.title.x=element_blank(), axis.text.y = element_blank(), axis.title.y=element_blank(), panel.grid = element_blank(), panel.border = element_blank(), legend.position = "none")
@
Below states we can select counties and census tracts.  At the county level, after we specify California we can look at counties within California (summary level 050).  We can see from figure \ref{fig:county} that we have selected Los Angeles county within California state.  This corresponds to an HTTP GET request of the following form: \url{http://api.census.gov/data/[YEAR]/[DATASET]?key=[KEY]&get=[VARIABLES]&for=county:037&in=state:06}.  There are a few other geographic regions we can subset by within a state such as ZIP code tabulation area; for example we can select 90210 which corresponds to Beverly Hills, California.\\
<<censustractstate, echo=FALSE, warning=FALSE, message=FALSE, out.width="3in", cache=TRUE, fig.show='hold', fig.cap='Pasadena county subdivision selected',  fig.align='center'>>=
library(maptools)
ca.tracts = readShapeSpatial("tl_2013_06_cousub.shp")
ca.geo = fortify(ca.tracts)
ca.data = ca.tracts@data
ca.geo$LA = 0
ca.geo[ca.geo$id %in% as.numeric(row.names(ca.data[which(ca.data$COUNTYFP=="037"),])),]$LA = 1
ca.geo[ca.geo$id == 13,]$LA = 2

qplot(long, lat, data=ca.geo, group=group, order=order, geom="polygon", fill=factor(LA)) + 
  theme_bw() + coord_map() + theme(axis.ticks = element_blank(), axis.text.x = element_blank(), axis.title.x=element_blank(), axis.text.y = element_blank(), axis.title.y=element_blank(), panel.grid = element_blank(), panel.border = element_blank(), legend.position = "none")

qplot(long, lat, data=subset(ca.geo, LA > 0), group=group, order=order, geom="polygon", fill=factor(LA)) + theme_bw() + coord_map() + theme(axis.ticks = element_blank(), axis.text.x = element_blank(), axis.title.x=element_blank(), axis.text.y = element_blank(), axis.title.y=element_blank(), panel.grid = element_blank(), panel.border = element_blank(), legend.position = "none")
@

There are a number of valid geographic entities below the state and county level.  For example, there are school districts, county subdivision, metropolitan statistical areas and legislative districts.  In order to form a valid HTTP GET request, smaller geographic divisions often require us to specify the containing state or county.  In figure \ref{fig:censustractstate} we have selected Pasadena, a county subdivision, within Los Angeles County.  For county subdivisions we cannot simply specify Pasadena and we also cannot specify just California and Pasadena; subdivision alone and state-subdivision are not a valid geographic combinations.  Instead, we must specify California, Los Angeles County and then Pasadena.  We can see from table \ref{tab:geolist} that state-county-subdivision is a valid summary level. \\
\\
Although all the entries in table \ref{tab:geolist} are valid geographic combinations, some parts of geographic combinations may be optional.  For example, if we wanted census tracts we need to specify state and county (summary level 140).  In contrast to county subdivisions where we needed to specify both state and county, for census tracts specifying county is optional.  This means that state-tract is also a valid geographic combination.  It is best to refer to each datasets JSON or XML file for geographic compatabilities.\\
\\
Due to the sheer number of different geographic entities there are geographic entities which cannot be used together for valid HTTP GET requests.  Some of the smaller geographic divisions are not necessarily nested in one of the larger geographic divisions; for example, ZIP code areas are generally used by the United States Postal Service and might span different counties or census tracts.  Additionally, Legislative districts do not line up with county borders and school districts often do not line up with either legislative districts or county borders.  See figure \ref{fig:iowa} to see a comparison of different geographic entities within Iowa.\\

<<iowa, echo=FALSE, echo=FALSE, warning=FALSE, message=FALSE, out.width="3in", cache=TRUE, fig.cap='Iowa State House Districts (top left), Iowa State Senate Districts (top right), Iowa Unified School Districts (bottom left), Iowa Counties (bottom right)',  fig.align='center', fig.show='hold'>>=
iowa.ld.lower = readShapeSpatial("tl_2013_19_sldl.shp")
iowa.ld.upper = readShapeSpatial("tl_2013_19_sldu.shp")
iowa.sd = readShapeSpatial("tl_2013_19_unsd.shp")

iowa.low.geo = fortify(iowa.ld.lower)
iowa.up.geo = fortify(iowa.ld.upper)
iowa.sd.geo = fortify(iowa.sd)

qplot(long, lat, data=iowa.low.geo, group=group, order=order, geom="path") + theme_bw() + coord_map() + theme(axis.ticks = element_blank(), axis.text.x = element_blank(), axis.title.x=element_blank(), axis.text.y = element_blank(), axis.title.y=element_blank(), panel.grid = element_blank(), panel.border = element_blank(), legend.position = "none")

qplot(long, lat, data=iowa.up.geo, group=group, order=order, geom="path") + theme_bw() + coord_map() + theme(axis.ticks = element_blank(), axis.text.x = element_blank(), axis.title.x=element_blank(), axis.text.y = element_blank(), axis.title.y=element_blank(), panel.grid = element_blank(), panel.border = element_blank(), legend.position = "none")

qplot(long, lat, data=iowa.sd.geo, group=group, order=order, geom="path") + theme_bw() + coord_map() + theme(axis.ticks = element_blank(), axis.text.x = element_blank(), axis.title.x=element_blank(), axis.text.y = element_blank(), axis.title.y=element_blank(), panel.grid = element_blank(), panel.border = element_blank(), legend.position = "none")

qplot(long, lat, data=subset(map_data('county'), region=="iowa"), group=group, order=order, geom="path") + theme_bw() + coord_map() + theme(axis.ticks = element_blank(), axis.text.x = element_blank(), axis.title.x=element_blank(), axis.text.y = element_blank(), axis.title.y=element_blank(), panel.grid = element_blank(), panel.border = element_blank(), legend.position = "none")
@

For a more detailed look at which geographies need to be specified, refer to the census bureau list of summary levels for each dataset or the XML or JSON geography files.  For the 2012 ACS dataset this is located at \url{http://api.census.gov/data/2012/acs5/geo.html}, the XML file is located at \url{http://api.census.gov/data/2012/acs5/geography.xml} and the JSON file is located at \url{http://api.census.gov/data/2012/acs5/geography.json}.    

\section{Finding Data Sets and Tables Structure}
\label{sec:var}
The Census Bureau API includes a master index of available dataset formatted in both JSON and XML.  The JSON file is available online at \url{http://api.census.gov/data.json} and the XML file is available online at \url{http://api.census.gov/data.xml}.  This master index includes necessary meta-information about each dataset including description, links to geography and variable information and contact information for maintainer of datasets.  The JSON format is formatted as follows:
\begin{verbatim}
{
  "c_vintage": 2012,
  "c_dataset":[ 
    "acs5"
  ],
  "c_geographyLink": "http://api.census.gov/data/2012/acs5/geography.json",
  "c_variablesLink": "http://api.census.gov/data/2012/acs5/variables.json",
  "c_tagsLink": "http://api.census.gov/data/2012/acs5/tags.json",
  "c_examplesLink": "http://api.census.gov/data/2012/acs5/examples.json",
  "c_documentationLink": "http://www.census.gov/developers/",
  "c_isAggregate": true,
  "title": "2012 American Community Survey: 5-Year Estimates",
  "webService": "http://api.census.gov/data/2012/acs5",
  "accessLevel": "public",
  "bureauCode": [
    "006:07"
  ],
  "contactPoint": "Census Bureau Call Center",
  "description": "The American Community Survey (ACS) is a nationwide survey...",
  "identifier": "2012acs5",
  "mbox": "pio@census.gov",
  "publisher": "US Census Bureau",
  "references": [
    "http://www.census.gov/developers/"
  ],
  "spatial": "US",
  "temporal": "2012"
  },
}
\end{verbatim}
The above excerpt from \url{http://api.census.gov/data.json} is the meta-information about the 2008-2012 ACS 5-year dataset.  For this dataset there are links to the associated geography file and to another JSON file $variables.json$ which is a list of variables available from this dataset.  For the above example the same meta-information is formatted in XML as follows:
\begin{verbatim}
<dataset vintage="2012" 
  geographyLink="http://api.census.gov/data/2012/acs5/geography.xml"
  variablesLink="http://api.census.gov/data/2012/acs5/variables.xml" 
  tagsLink="http://api.census.gov/data/2012/acs5/tags.xml" 
  examplesLink="http://api.census.gov/data/2012/acs5/examples.xml" 
  documentationLink="http://www.census.gov/developers/" 
  pod:webService="http://api.census.gov/data/2012/acs5" isAggregate="true" 
  pod:accessLevel="public" 
  dcat:contactPoint="Census Bureau Call Center" 
  dct:identifier="2012acs5" 
  pod:mbox="pio@census.gov" 
  dct:publisher="US Census Bureau" 
  dct:spatial="US" 
  dct:temporal="2012">
<dataset-name> <part name="acs5"/> </dataset-name>
<dct:title>2012 American Community Survey: 5-Year Estimates</dct:title>
<pod:bureauCode> 006:07 </pod:bureauCode>
<dct:description>
The American Community Survey (ACS) is a nationwide survey...
</dct:description>
<pod:reference link="http://www.census.gov/developers/"/>
</dataset>
\end{verbatim}
After the user has selected the dataset of interest, they will need to lookup what variables are available for that dataset.  The JSON and XML master index of datasets contain the location of $variables.json$ and $variables.xml$ respectively which list available variables available for that dataset.  Available variables are organized into tables referred to as "concepts"; a "concept" is a combination of factors.  For example, "Health Insurance Coverage Status by Sex by Age" is a concept from the 2012 ACS.  Within each "concept" are "labels"; a "label" is a combination of levels for the factors within a concept.\\
\\
Within each concept there are multiple labels that provide information on different levels of each of the factors.  For example, the concept "Health Insurance Coverage Status by Sex by Age" contains a label for males over 70 with health insurance.  This concept also contains labels for each combination of gender (male, female), age group (under 6, 6 to 17, 18 to 24, 25 to 34, 35 to 44, 45 to 54, 55 to 64, 65 to 74 and 75 and over) and health insurance coverage (with and without health insurance).  Some of the labels may also contain summary information in the form of totals.  For this concept there are labels for total number of males, total number of females and totals for males/females in each age group.\\
\\
To lookup what variables are available, the $variables.json$ and $variables.xml$ files contain a list of all concepts and labels along with a description.  The JSON formatted $variables.json$ is formatted as follows:
\begin{verbatim}
"B27001_056E": {
  "label": "Female:!!75 years and over:!!With health insurance coverage",
  "concept": "B27001.  Health Insurance Coverage Status by Sex by Age"
},
\end{verbatim}
This describes label 056E of concept B27001.  This is a table of 75 and older females with health insurance.  The associated XML formatted version is formatted as follows:
\begin{verbatim}
<var xml:id="B27001_056E" 
  label="Female:!!75 years and over:!!With health insurance coverage" 
  concept="B27001. Health Insurance Coverage Status by Sex by Age"/>
\end{verbatim}
Once we have found the concepts or labels we are interested in, we can form a valid HTTP GET request using the concept-label ID.  For the health insurance coverage status by sex by age concept we can request the 75 and older female with health insurance label using the concept-label ID $B27001\_056E$.  A valid HTTP GET request for this is \url{http://api.census.gov/data/[YEAR]/[DATASET]?key=[KEY]&get=B27001_056E&for=[GEOGRAPHY]}.

<<dataexample, echo=FALSE, cache=TRUE, results='asis'>>=
library(rjson)
library(plyr)
url = "http://api.census.gov/data/2012/acs5?key=b59354d11f96afaa8cbd17c5f9e5cdf7d057fc1c&get=B27001_036M,B27001_037M,NAME&for=county:*&in=state:06"
js = fromJSON(file=url)
df = ldply(js)
names(df) = df[1,]
df = df[-1,]

print(xtable(head(df), label="tab:df", caption="Health insurance status of women 75 years and older in California by county from 2012 ACS 5-year data"))
@

Table \ref{tab:df} is information on health insurance for women 75 and older in California from the 2012 ACS 5-year data listed by county.  The HTTP GET request for this is \url{http://api.census.gov/data/2012/acs5?key=[KEY]&get=B27001_056E,B27001_057E,NAME&for=county:*&in=state:06}.  Labels 056E and 057E are labels for women 75 and older with health insurance and women 75 and older without health insurance respectively.  The result of our HTTP GET request is a JSON formatted file in the following format:
\begin{verbatim}
[["B27001_036M","B27001_037M","NAME","state","county"],
["668","144","Alameda County, California","06","001"],
["15","69","Alpine County, California","06","003"],
["88","131","Amador County, California","06","005"],
["238","127","Butte County, California","06","007"],
["45","102","Calaveras County, California","06","009"],
["98","26","Colusa County, California","06","011"],
\end{verbatim}
This indicates that there are 668 women over 75 in Alameda county that have health insurance and 144 women over 75 in Alameda county without health insurance.

\section{Limitations}
The dataset used by \citet{stangl:2013} is a random subset of the 2010 ACS public use microdata sample.  This article contains a number of classroom exercises that ask the reader to calculate some basic proportions about various demographic data.  We will attempt to use the Census Bureau online API to examine the same demographic variables.\\
\\
Using the Census Bureau's online API for these exercises presents us three main problems.  The first problem is the structure of how the data is organized in the public use microdata sample versus how the data is organized in the online API.  The second problem is that the census does not provide proportions and finding standard errors for these proportions requires a bit more work.  Finally, the third problem is that certain combination of variables are simply not available from the online API.
<<table, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE, results="asis", fig.cap='Subset of data used in Chance Article'>>=
library(xtable)
acsdat = read.csv("datasetSTANGL2013.csv") #chance article dataset
print(xtable(head(acsdat), label="tab:table", caption="Random subset of 2010 ACS public use microdata sample"))
#structure of data isn't a dataframe but multiple tables
#each table has a different "base population"
#sometimes base population for similar variables does not add up
@
Data from the ACS public use microdata sample is organized to describe individuals.  Each row of the dataset describes an anonymized individual and each column represents a different demographic variable.  See table \ref{tab:table} for a small subset of the data used by Morgan et al.\\
<<example, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE, results="asis", fig.cap='Health care data from online API'>>=
library(acs)
library(xtable)
states = geo.make(state = "*")
dat = acs.fetch(endyear = 2012, span = 5, geography = states, table.number="B27001")
dat2 = acs.fetch(endyear = 2012, span = 5, geography = states, table.number="B27001", col.names="pretty")

dat.table = data.frame(dat@estimate[,1:5])
names(dat.table) = c("Total", "M Total", "M <6", "M <6 w/insurance", "M <6 w/o insurance")

tab1 = xtable(head(dat.table), label="fig:example", caption="Health Insurance Coverage information from Census API.  Each of the M columns indicate male, subsequent numbers indicate age; there are corresponding F columns for females that is not shown to conserve space.")
digits(tab1) = rep(0,6)
print(tab1)
@
By contrast the online API does not provide individual specific data.  When we perform a HTTP GET request we must specify what geographic level of detail we want.  The geographic level of detail does not go below the county subdivision or census tract level.  Instead of individual specific data we have data that has been aggregated for an entire geographic region.  This is likely due to privacy reasons; if we have individual specific data for a dozen demographic variables along with geographic information it might be possible to reveal this individual's identity.  \\
\\
In table \ref{fig:example} we specify state level summaries for health insurance coverage status for various age groups by gender (from the census API this is table B27001).  Each variable is in the form of a table and as previously mentioned we refer to this as a $concept$ and each column in table \ref{fig:example} is referred a $label$.  The first label of each concept is an overall total; the total number of people in the specified geographic region that answered questions relating to the requested concept.   Subsequent labels are subsets of this overall total.  We've conveniently renamed column headers in table \ref{fig:example}; the naming convention from data provided by the API is to enumerate each label with the table name: $B27001\_001$, $B27001\_002$ etc.\\
\\
The way this data is organized is not tidy $<$include hadley tidy data reference$>$.  Instead it appears that the columns contain additional categorical information: gender, age and insurance.  In table \ref{fig:tidy} we have tidied up the data so that each row is an observation and each column is a variable.  Originally table B27001 contains a number of $total$ columns: overall total, total number of males, total number of females, and within each gender a total number of people within an age group.  In reshaping this data, we felt that these total columns were redundant once the data is in a tidy form.  \\
\\

<<melted, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE, results="asis">>=
library(reshape2)
dat.tidy = data.frame(dat2@estimate)
dat.tidy$state = rownames(dat.tidy)
rownames(dat.tidy) = NULL
names(dat.tidy) = gsub("Health.Insurance.Coverage.Status.by.Sex.by.Age..", "", names(dat.tidy))
dat.tidy = dat.tidy[,c(grep("health.insurance", names(dat.tidy)),58)]
dat.tidy.melt = melt(dat.tidy, id='state')

v = strsplit(as.character(dat.tidy.melt$variable), "\\.\\.")
v = data.frame(matrix(unlist(v), nrow=1872, byrow=T))
names(v) = c("gender", "age", "insurance")
levels(v$insurance) = c("no", "yes")
levels(v$age) = c("18-24", "25-34", "35-44", "45-54", "55-64", "6-17", "65-74", "75+", "<6")
levels(v$gender) = c("f", "m")

final = data.frame(state = dat.tidy.melt$state, gender = v$gender, age = v$age, insurance = v$insurance, freq = dat.tidy.melt$value)

tab2 = xtable(head(final), label="fig:tidy", caption="Reshaped Health Insurance Coverage data.")
digits(tab2) = rep(0,6)
print(tab2)
@


<<var, echo=FALSE>>=
#example1: (chance #3, #5)
#age + sex + health insurance available.
#age + race + health insurance available.
#age + race + sex + health insurance not available

#example2: (chance #4)
#age + sex + marriage available
#race + sex + marriage available
#age + sex + race + marriage not available

#example3: (chance #6)
#age + sex + race available
#numbers don't match with example1 for aggregates

#example4: (chance #7)
#median income + sex + work experience available.
#per capita income + race available
#per capita income + race + sex not available
#median income + sex + race not available

#example5: (change#9)
#chance #8 available
#chance #9 not available #10
@

\section{Other Issues}
%tables formatted differently
%2010acs5 differently formatted
%difficult to compare data across years
%healthcare questions added in 2008

\section{Examples from ACS}
<<NY, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE>>=
library(plyr)
library(acs)

NYC = geo.make(state="NY", county=c("New York County", "Bronx County", "Kings County", "Queens County", "Richmond County"), tract="*")
f.nyc = acs.fetch(endyear = 2012, span = 5, geography = NYC, table.name = c("In Combination With One Or More Other Races"), col.names="pretty")

library(maptools)
ny.tracts = readShapeSpatial("Z:/My Documents/shapes/nyct2010.shp")
ny.tracts@data$id = rownames(ny.tracts@data)
ny.points = fortify(ny.tracts)
ny.df = join(ny.points, ny.tracts@data, by="id")
#CTlabel = censustract label

#merge shapefile data with ACS data
f.nyc = data.frame(f.nyc@estimate)

split=ldply(strsplit(rownames(f.nyc), ","))
f.nyc$state = tolower(sub("^.*, ", "", rownames(f.nyc)))
f.nyc$tract = tolower(gsub("Census Tract ", "", split[,1]))
f.nyc$county = tolower(gsub("^[ ]","",split[,2]))
f.nyc$county = gsub(" county", "", f.nyc$county)
f.nyc$county = gsub("kings", "brooklyn", f.nyc$county)
f.nyc$county = gsub("new york", "manhattan", f.nyc$county)
f.nyc$county = gsub("richmond", "staten island", f.nyc$county)
rownames(f.nyc) = NULL

f.nyc$tract = as.numeric(f.nyc$tract)
ny.df$CTLabel = as.numeric(as.character(ny.df$CTLabel))
ny.df$BoroName = tolower(ny.df$BoroName)

final = merge(x = ny.df, y = f.nyc, by.x = c("CTLabel", "BoroName"), by.y = c("tract", "county"), all.x=TRUE)
names(final)[19:24] = c("white", "black", "indian", "asian", "hawaiian", "other")



final$race = unlist(apply(final[,19:24], 1, function(x){
  if(sum(is.na(x)) == length(19:24)) return("NA")
  else return(names(which.max(x)))
}))
qplot(long, lat, data = final, group=group, order=order, geom="polygon", fill=race) + theme_bw() + theme(axis.ticks = element_blank(), axis.text.x = element_blank(), axis.title.x=element_blank(), axis.text.y = element_blank(), axis.title.y=element_blank(), panel.grid = element_blank(), panel.border = element_blank())
@


<<test, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE>>=
library(maptools)
library(ggplot2)
library(plyr)
library(ggmap)
library(acs)

ny.shape = readShapeSpatial("Z:/My Documents/shapes/tl_2013_36_tract.shp")
ny.shape@data$id = rownames(ny.shape@data)
ny.points = fortify(ny.shape)
ny2.df = join(ny.points, ny.shape@data, by="id")
#by county
#subset(fips.county, State=='NY') #61, 5, 47, 81, 85
qmap("brooklyn new york city", zoom=11) + geom_path(aes(x = long, y = lat, group=group, order=order), data = subset(ny2.df, COUNTYFP %in% c("061", "005", "047", "081", "085")))
@
\section{Conclusion}
\printbibliography

\end{document}