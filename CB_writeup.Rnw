\documentclass{article}
\usepackage{url}
\usepackage{amsfonts}
\usepackage[margin=1in]{geometry}
\setlength{\parindent}{0in}

\title{Accessing Data with the Census Bureau API}
\author{Alex Shum}
\begin{document}
\maketitle

\section{Introduction}
The United States Census Bureau has been conducting a decennial census since 1790.  Originally this census was a simply to count the population across the country.  More recently the decennial census includes a short-form asking for name, sex, age, and a few other demographic variables.  About one in six households also received a long-form that contained additional socioeconomic questions.  After the 2000 decennial census many of the long-form questions were collected as part of a new survey: the American Community Survey (ACS).  \\
\\
The ACS is an ongoing yearly survey that collects additional demographic variables including but not limited to age, sex, race, income and education.  Unlike the decennial census, the American Community Survey is distributed based on a random selection of addresses every year.  Although the ACS is only sent to a sample of all US households, this data is meant to provide more up to date information than the Census Bureau's decennial census.  Both the decennial census and the American Community Survey are required to be completed by law; however it should be noted that the Census Bureau has not opted to prosecute anyone for failure to complete the decennial census or the ACS.  Despite the lack of enforcement, the ACS still reports a response rate of 97$\%$.\\ %http://www.politifact.com/texas/statements/2014/jan/09/us-census-bureau/americans-must-answer-us-census-bureau-survey-law-/
\\
Both the decennial survey and the ACS data are used in part by federal, state and local agencies to allocate state funding and for policy decisions.  The Census Bureau has also released some of this data for public use.  Many of the data sets are available directly in a compressed format from the Census Bureau's FTP site: \url{http://ftp2.census.gov/}.  Since 2012, the Census Bureau has also included an online developer's API in order to improve accessibility of the ACS and decennial census datasets.  The Census Bureau's online API can be accessed online: \url{http://api.census.gov}.\\
\\
We will discuss how the ACS data is structured when we request data and how to access data from the Census Bureau's online developer's API.  We will also discuss what kind of variables are available and some limitations with the API.  We will use "Taking a Chance in the Classroom: The American Community Survey", an article by Morgan, Cetinkaya-Rundel and Stangl as a starting point on some of the limitations of the API.  This article explores some multivariate frequency distributions using data from the ACS dataset; however, there are some gaps in what we can access and inconsistencies in the database.

\section{Geography}
The Census Bureau has a very sophisticated system of hierarchy for geography.  For the ACS, at the top level there is the entire nation, followed by region, division, state, county, county-subdivision, tract, block group, place, congressional district, zip code area, school district and a few other geographic divisions.  See table \ref{tab:geolist} for a complete table of geographies available on the census API for the 2012 ACS.\\

<<geotable, echo=FALSE, warning=FALSE, message=FALSE, eval=FALSE>>=
#http://api.census.gov/data/2012/acs5/geo.html
library(xtable)
library(XML)
ta = readHTMLTable("http://api.census.gov/data/2012/acs5/geo.html")[[1]]
ta = ta[,-3]
tabl = xtable(ta)
caption(tabl) = "List of valid geographic combinations"
@
\begin{table}[ht]
\centering
\begin{tabular}{rll}
  \hline
 & Summary Level & Description \\ 
  \hline
  1 & 010 & us \\ 
  2 & 020 & region \\ 
  3 & 030 & division \\ 
  4 & 040 & state \\ 
  5 & 050 & state-county \\ 
  6 & 060 & state-county-county subdivision \\ 
  7 & 140 & state-county-tract \\ 
  8 & 150 & state-county-tract-block group \\ 
  9 & 160 & state-place \\ 
  10 & 250 & american indian area/alaska native area/hawaiian home land \\ 
  11 & 310 & metropolitan statistical area/micropolitan statistical area \\ 
  12 & 320 & state-metropolitan statistical area/micropolitan statistical area \\ 
  13 & 330 & combined statistical area \\ 
  14 & 340 & state-combined statistical area \\ 
  15 & 350 & new england city and town area \\ 
  16 & 400 & urban area \\ 
  17 & 500 & state-congressional district \\ 
  18 & 510 & state-congressional district-county \\ 
  19 & 610 & state-state legislative district (upper chamber) \\ 
  20 & 620 & state-state legislative district (lower chamber) \\ 
  21 & 795 & state-public use microdata area \\ 
  22 & 860 & zip code tabulation area\\
  23 & 950 & state-school district (elementary) \\ 
  24 & 960 & state-school district (secondary) \\ 
  25 & 970 & state-school district (unified) \\ 
   \hline
\end{tabular}
\caption{List of valid geographic combinations}
\label{tab:geolist}
\end{table}

From table \ref{tab:geolist}, the hierarchy for geographic regions is very specific in the combinations of geographic regions that we can specify.  Different ACS datasets might have slightly different geographic regions available.  Fortunately, each dataset available on the Census Bureau online API include an associated geography file formatted in JSON and a similar file formatted in XML.  JSON stands for JavaScript Object Notation and it is a lightweight machine format for sending data.  JSON is structured using name-value pairs and is also designed to be human-readable.  There are many libraries to generate and process JSON.  The JSON formatted file for geographies has the following format:
\begin{verbatim}
{
  "name": "tract",
  "requires:" [
    "state",
    "county"
  ],
  "optionalWithWCFor": "county"
}
\end{verbatim}
This JSON file specifies that for census tract level geography we are required to specify a state.  Additionally we can also specify both a state and a county.\\
\\
Alternatively, the geographic information is available in XML.  XML stands for Extensible Markup Language and is similar in structure to the HTML format used for webpages.  XML is another format for sending and storing data.  It is formatted in a tree-like structure with a hierarchy of categories with associated values.  Here is the same geographic area information formatted in XML:
\begin{verbatim}
<fips name="tract">
  <requires name="state"/>
  <requires name="county" is-optional-with-wcfor="true"/>
</fips>
\end{verbatim}
In the following example, we will examine various geographies available from the online API for the state of California.\\
<<state, echo=FALSE, warning=FALSE, message=FALSE, fig.height=3, cache=TRUE, fig.cap='California selected'>>=
library(ggplot2)
states.map = map_data("state")
states.map$CA = states.map$region=="california"
qplot(long, lat, data=states.map, group=group, order=order, geom="polygon", fill=CA) + 
  theme(legend.position = "none")
@
At the top of the hierarchy we can view data at the country level; this is data aggregated among all states and corresponds to summary level 010 from table \ref{tab:geolist}.  Below that we can view data by state.  At the state level we can view data for all states or select a particular state; this is summary level 040.  In figure \ref{fig:state} we have selected California.\\

<<county, echo=FALSE, warning=FALSE, message=FALSE, fig.height=3, cache=TRUE, fig.cap='Los Angeles county selected'>>=
counties.map = map_data("county")
counties.map$CA = as.numeric(counties.map$region=="california")
counties.map[counties.map$region=="california" & counties.map$subregion=="los angeles",]$CA = 2
qplot(long, lat, data=counties.map, group=group, order=order, geom="polygon", fill=factor(CA)) + 
  theme(legend.position = "none")
@
Below states we can select counties and census tracts.  At the county level, after we specify California we can look at counties within California (summary level 050).  We can see from figure \ref{fig:county} that we have selected Los Angeles county within California state.  There are a few other geographic regions we can subset by within a state such as ZIP code tabulation area; we could have selected 90210 which corresponds to Beverly Hills, California.\\
<<censustractstate, echo=FALSE, warning=FALSE, message=FALSE, out.width="3in", cache=TRUE, fig.show='hold', fig.cap='Pasadena county subdivision selected'>>=
library(maptools)
ca.tracts = readShapeSpatial("tl_2013_06_cousub.shp")
ca.geo = fortify(ca.tracts)
ca.data = ca.tracts@data
ca.geo$LA = 0
ca.geo[ca.geo$id %in% as.numeric(row.names(ca.data[which(ca.data$COUNTYFP=="037"),])),]$LA = 1
ca.geo[ca.geo$id == 13,]$LA = 2
qplot(long, lat, data=ca.geo, group=group, order=order, geom="polygon", fill=factor(LA)) + 
  theme(legend.position = "none") 
qplot(long, lat, data=subset(ca.geo, LA > 0), group=group, order=order, geom="polygon", fill=factor(LA)) + theme(legend.position = "none")
@

There are a number of geographies available below the state and county level.  For example, the API also supports school districts, county subdivision, metropolitan statistical areas and legislative districts.  The difficulty is that it is not possible to request data for many of the smaller geographic divisions without specifying a state or a county.  In figure \ref{fig:censustractstate} we have selected Pasadena, a county subdivision, within Los Angeles County.  For county subdivisions we cannot simply specify Pasadena and we also cannot specify just California and Pasadena; subdivision alone and state-subdivision are not a valid geographic combinations.  Instead, we must specify California, Los Angeles County and then Pasadena.  We can see from table \ref{tab:geolist} that state-county-subdivision is a valid summary level. \\
\\
Although all the entries in table \ref{tab:geolist} are valid geographic combinations, some parts of geographic combinations may be optional.  For example, if we wanted census tracts we need to specify state and county (summary level 140).  In contrast to county subdivisions where we needed to specify both state and county, for census tracts specifying county is optional.  This means that state-tract is also a valid geographic combination.  It is best to refer to each datasets JSON or XML file for geographic compatabilities.\\
\\
Another complication is that not all geographic divisions are compatible.  That is to say that some of the smaller geographic divisions are not necessarily nested in one of the larger geographic divisions; for example, ZIP code areas are generally used by the United States Postal Service and might span different counties or census tracts.  Additionally, Legislative districts do not line up with county borders and school districts often do not line up with either legislative districts or county borders.
%Insert Iowa example here
\\
\\
For a more detailed look at which geographies need to be specified, refer to the census bureau list of summary levels for each dataset or the XML or JSON geography files.  For the 2012 ACS dataset this is located at \url{http://api.census.gov/data/2012/acs5/geo.html}, the XML file is located at \url{http://api.census.gov/data/2012/acs5/geography.xml} and the JSON file is located at \url{http://api.census.gov/data/2012/acs5/geography.json}.

\section{Finding Data Sets and Tables}
%XML/JSON structure for variables list
A recent addition to the Census Bureau API is the inclusion of a master index of available dataset formatted in both JSON and XML.  

\section{Requesting Data and Table Structure}
%explain get queries here

\section{Limitations}
The dataset used by Morgan, Cetinkaya-Rundel and Stangl in "Taking a Chance in the Classroom: The American Community Survey" is a random subset of the 2010 ACS public use microdata sample.  This article contains a number of classroom exercises that ask the reader to calculate some basic proportions about various demographic data.  We will attempt to use the Census Bureau online API to examine the same demographic variables.\\
\\
Using the Census Bureau's online API for these exercises presents us three main problems.  The first problem is the structure of how the data is organized in the public use microdata sample versus how the data is organized in the online API.  The second problem is that the census does not provide proportions and finding standard errors for these proportions requires a bit more work.  Finally, the third problem is that certain combination of variables are simply not available from the online API.
<<table, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE, results="asis", fig.cap='Subset of data used in Chance Article'>>=
library(xtable)
acsdat = read.csv("datasetSTANGL2013.csv") #chance article dataset
print(xtable(head(acsdat)))
#structure of data isn't a dataframe but multiple tables
#each table has a different "base population"
#sometimes base population for similar variables does not add up
@
Data from the ACS public use microdata sample is organized to describe individuals.  Each row of the dataset describes an anonymized individual and each column represents a different demographic variable.  See figure \ref{fig:table} for a small subset of the data used by Morgan et al.
<<example, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE, results="asis", fig.cap='Health care data from online API'>>=
library(acs)
library(xtable)
states = geo.make(state = "*")
dat = acs.fetch(endyear = 2012, span = 5, geography = states, table.number="B27001")
dat2 = acs.fetch(endyear = 2012, span = 5, geography = states, table.number="B27001", col.names="pretty")

tab1 = xtable(head(dat@estimate[,1:5]))
digits(tab1) = rep(0,6)
print(tab1)
@
By contrast the online API does not provide individual level data.  When we perform a get query we must specify what geographic level of detail we want.  In table \ref{fig:example} we specify state level summaries for table variable B27001.  Table variable B27001 is related to health insurance coverage status for various age groups grouped by gender.  Each column in table \ref{fig:example} is a sub-table on B27001.

<<var, echo=FALSE>>=
#example1: (chance #3, #5)
#age + sex + health insurance available.
#age + race + health insurance available.
#age + race + sex + health insurance not available

#example2: (chance #4)
#age + sex + marriage available
#race + sex + marriage available
#age + sex + race + marriage not available

#example3: (chance #6)
#age + sex + race available
#numbers don't match with example1 for aggregates

#example4: (chance #7)
#median income + sex + work experience available.
#per capita income + race available
#per capita income + race + sex not available
#median income + sex + race not available

#example5: (change#9)
#chance #8 available
#chance #9 not available #10
@

\section{Other Issues}
%tables formatted differently
%2010acs5 differently formatted
%difficult to compare data across years
%healthcare questions added in 2008

\section{Examples from ACS}
<<NY, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE>>=
library(plyr)
library(acs)
NYC = geo.make(state="NY", county=c("New York County", "Bronx County", "Kings County", "Queens County", "Richmond County"), tract="*")
f.nyc = acs.fetch(endyear = 2012, span = 5, geography = NYC, table.name = c("In Combination With One Or More Other Races"), col.names="pretty")

library(maptools)
ny.tracts = readShapeSpatial("Z:/My Documents/shapes/nyct2010.shp")
ny.tracts@data$id = rownames(ny.tracts@data)
ny.points = fortify(ny.tracts)
ny.df = join(ny.points, ny.tracts@data, by="id")
#CTlabel = censustract label

#merge shapefile data with ACS data
f.nyc = data.frame(f.nyc@estimate)

split=ldply(strsplit(rownames(f.nyc), ","))
f.nyc$state = tolower(sub("^.*, ", "", rownames(f.nyc)))
f.nyc$tract = tolower(gsub("Census Tract ", "", split[,1]))
f.nyc$county = tolower(gsub("^[ ]","",split[,2]))
f.nyc$county = gsub(" county", "", f.nyc$county)
f.nyc$county = gsub("kings", "brooklyn", f.nyc$county)
f.nyc$county = gsub("new york", "manhattan", f.nyc$county)
f.nyc$county = gsub("richmond", "staten island", f.nyc$county)
rownames(f.nyc) = NULL

f.nyc$tract = as.numeric(f.nyc$tract)
ny.df$CTLabel = as.numeric(as.character(ny.df$CTLabel))
ny.df$BoroName = tolower(ny.df$BoroName)

final = merge(x = ny.df, y = f.nyc, by.x = c("CTLabel", "BoroName"), by.y = c("tract", "county"), all.x=TRUE)
names(final)[19:24] = c("white", "black", "indian", "asian", "hawaiian", "other")



final$race = unlist(apply(final[,19:24], 1, function(x){
  if(sum(is.na(x)) == length(19:24)) return("NA")
  else return(names(which.max(x)))
}))
qplot(long, lat, data = final, group=group, order=order, geom="polygon", fill=race)
@

\section{Conclusion}
\end{document}